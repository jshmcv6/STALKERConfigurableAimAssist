local zoom_in = false
local LastTarget = nil
local turn_on = true
local assist_toggled_on = true -- This is our master toggle

-- A list of magnification levels we will use in the script
local mag_levels = {
	"hipfire",   -- For 'Fire Mode'
	"irons",     -- For 1x, red dots, and iron sights
	"low_zoom",  -- For 2x-4x scopes
	"high_zoom"  -- For 6x+ scopes
}

-- We will store settings in these tables, indexed by mag_level
local radius_table = {}
local smooth_table = {}
local retention_table = {}
local retention_tightness_table = {}
local resist_threshold_table = {}
local switch_hysteresis_table = {}
local switch_cooldown_table = {}  -- NEW: Table for per-level switch cooldown

-- Get the console to read the player's base FOV
local console = get_console()
-- Read the base FOV on load. Default to 75 if not set.
local base_player_fov = console:get_float("fov") or 75.0

local last_aim_time = 0
local last_set_yaw = 0
local last_set_pitch = 0
local last_switch_time = 0  -- NEW: Track time of last target switch

local raycast_timeout = 0
local raycast_delay = 60 -- 10 real ms between raycasts because in-game time is 6 : 1 real-time
local last_raycast_was_visible = true

-- Lerp function (from geometry script)
local function lerp(a, b, f)
    if a and b and f then
        return a + f * (b - a)
    else
        return a or b or 0
    end
end

-------------------------------------------------MCM stuff--------------------------------------------------------------------------------

local get_config = aim_mcm.get_config

function translate_bone(number)
	local bone_guide = {
		[1] = "bip01_head",
		[2] = "bip01_neck",
		[3] = "bip01_spine",
	}
	return bone_guide[number]
end

function on_option_change()
	-- Compute effective values for tables
	local style = get_config("assist_style") or 0.5
	local controller_opt = get_config("controller_optimized")
	
	-- Now for each level
	for _, level in ipairs(mag_levels) do
		-- Get per-level override and feel
		local override = get_config(level .. "_override") or false
		local feel = get_config(level .. "_feel") or 0.5
		local effective_style = override and feel or style
		
		-- Step 1: Set bases with effective style (full reset)
		local base_radius = lerp(1.0, 0.7, effective_style)
		local base_smooth_factor = lerp(0.01, 1.0, effective_style)
		local base_retention_radius = lerp(1.0, 0.7, effective_style)
		local base_retention_tightness = lerp(100, 0, effective_style)
		local base_resist_threshold = lerp(2.0, 0, effective_style)
		local base_switch_hysteresis = lerp(0, 2.0, effective_style)
		local base_switch_cooldown = lerp(0, 5, effective_style)
		
		-- No Step 2: No macros, so computed = base
		local computed_radius = base_radius
		local computed_smooth_factor = base_smooth_factor
		local computed_retention_radius = base_retention_radius
		local computed_retention_tightness = base_retention_tightness
		local computed_resist_threshold = base_resist_threshold
		local computed_switch_hysteresis = base_switch_hysteresis
		local computed_switch_cooldown = base_switch_cooldown
		
		-- Step 3: Controller optimization (applied to computed)
		if controller_opt then
			computed_resist_threshold = computed_resist_threshold * 0.5  -- Lower for easy slow breaks
			computed_retention_tightness = computed_retention_tightness * 0.5  -- Stickier
		end
		
		-- Step 4: Force-set all MCM keys to computed values (overrides everything)
		ui_mcm.set("aim_assist/" .. level .. "_radius", computed_radius)
		ui_mcm.set("aim_assist/" .. level .. "_smooth_factor", computed_smooth_factor)
		ui_mcm.set("aim_assist/" .. level .. "_retention_radius", computed_retention_radius)
		ui_mcm.set("aim_assist/" .. level .. "_retention_tightness", computed_retention_tightness)
		ui_mcm.set("aim_assist/" .. level .. "_resist_threshold", computed_resist_threshold)
		ui_mcm.set("aim_assist/" .. level .. "_switch_hysteresis", computed_switch_hysteresis)
		ui_mcm.set("aim_assist/" .. level .. "_switch_cooldown", computed_switch_cooldown)
		
		-- Step 5: Set tables to final (after set, for in-game use)
		radius_table[level] = computed_radius
		smooth_table[level] = computed_smooth_factor
		retention_table[level] = computed_retention_radius
		retention_tightness_table[level] = computed_retention_tightness
		resist_threshold_table[level] = computed_resist_threshold
		switch_hysteresis_table[level] = computed_switch_hysteresis
		switch_cooldown_table[level] = computed_switch_cooldown
	end

	-- Load Global Settings
	master_switch = get_config("master_switch")
	bone = translate_bone( get_config("main_bone") )
	toggle_keybind = get_config("toggle_keybind")
	time_out_checkbox = get_config("time_out_checkbox")
	time_out_input = tonumber(get_config("time_out_input")) or 0.5
	limit_mode = get_config("limit_mode")
	limit_value = tonumber(get_config("limit_value")) or 10
	frendly_fire = get_config("frendly_fire")
	closer_wider = get_config("closer_wider")
	closer_wider_value = tonumber(get_config("closer_wider_value")) or 0.7
	closer_wider_distance = tonumber(get_config("closer_wider_distance")) or 0
	
	-- Re-read base FOV in case the player changed it in the main menu
	base_player_fov = console:get_float("fov") or 75.0
end

local function limit_equation(obj)
	local dist = distance_between_safe(db.actor, obj)
	if not dist or type(dist) ~= "number" or dist ~= dist then
		return false
	end
	return limit_mode == 0 or
	(limit_mode == -1) and (dist <= limit_value) or
	(limit_mode == 1) and (dist >= limit_value)
end

-- ===================================================================
-- THIS IS THE NEW CORE FUNCTION
-- It replaces get_current_weapon_kind()
-- ===================================================================
function get_current_mag_level()
    -- 1. Check if not aiming (hipfire)
	-- Your script already tracks this with the zoom_in variable
    if not zoom_in then
        return "hipfire"
    end
    
    -- 2. Get the *current* camera FOV.
    -- This value is changed by the engine when you zoom.
    local current_cam_fov = device().fov 
    
    -- 3. Calculate magnification
    local mag = base_player_fov / current_cam_fov
    
    -- 4. Return the correct category
    -- Tweak these values to your liking!
    if mag < 1.9 then
        return "irons"       -- (Covers 1x Red Dots and most Iron Sights)
    elseif mag < 5.5 then
        return "low_zoom"  -- (Covers 2x-4x scopes, ACOG, etc.)
    else
        return "high_zoom"   -- (Covers 6x, 8x, and higher)
    end
end
-- ===================================================================


---------------------------------------------main------------------------------------------------------------------------------------

function dot_eye(position)
	if not position then return nil end
	local toPoint = vector():set(position):sub(device().cam_pos):normalize()
	local toEye = device().cam_dir
	local dot = toPoint:dotproduct(toEye)
	return dot
end

local function pos_y(obj)
	if not(obj) then return nil end
	local pos = vector():set(obj:position())
	pos.y = pos.y + 1
	return pos
end

function is_valid_object(obj)
	if not(obj) then return end
	if not limit_equation(obj) then return end
	
	if ( (frendly_fire and IsStalker(obj)) or
	(IsStalker(obj) and (obj:relation(db.actor) >= game_object.enemy)) or
	IsMonster(obj) ) and
	obj:alive() and db.actor:see(obj) or
	IsHelicopter(obj) and obj:alive()
	then
		return true
	else
		return
	end
end

-- Updated to use mag_level instead of kind
function dot_check(obj, mag_level)
	if not(obj) or not mag_level then return end
	if not obj:alive() then return nil end
	
	local pos = obj:get_bone_id(bone) == 65535 and pos_y(obj) or utils_obj.safe_bone_pos(obj, bone)
	if not pos then return nil end
	
	local dot = dot_eye(pos)
	if not dot then return nil end
	
	local active_radius = radius_table[mag_level] or 0.995 
	local retention_radius = retention_table[mag_level] or 0.995
	local retention_tightness = retention_tightness_table[mag_level] or 1.0
	
	local trigger_zone = active_radius
	if LastTarget and obj:id() == LastTarget:id() then
		trigger_zone = 1 - math.pow(1 - retention_radius, retention_tightness)
		trigger_zone = math.min(trigger_zone, 1.0)
	end
	
	local dist = distance_between_safe(db.actor, obj)
	if closer_wider and dist and type(dist) == "number" and dist == dist and type(closer_wider_distance) == "number" and closer_wider_distance == closer_wider_distance and type(closer_wider_value) == "number" and closer_wider_value == closer_wider_value and dist <= closer_wider_distance then
		trigger_zone = math.min(trigger_zone, closer_wider_value)
	end

	if type(dot) ~= "number" or type(trigger_zone) ~= "number" or dot ~= dot or trigger_zone ~= trigger_zone then
		return nil
	end

	if dot >= trigger_zone then
		return dot
	else
		return nil
	end
end

-- Updated to use mag_level instead of kind, with hysteresis bias
function search_target(mag_level)
	if not mag_level then return end
	local t = db.storage
	local best_dot = -1
	local best_target = nil
	local hysteresis = switch_hysteresis_table[mag_level] or 0.01

	for id, st in pairs(t) do
		if st.object and is_valid_object(st.object) then
			local dot = dot_check(st.object, mag_level) 
			if dot and type(dot) == "number" and dot == dot then
				if LastTarget and st.object:id() == LastTarget:id() then
					dot = dot + hysteresis
				end
				if dot > best_dot then
					best_dot = dot
					best_target = st.object
				end
			end
		end
	end

	-- NEW: If a new target is selected (switch happened), update last_switch_time
	if best_target and (not LastTarget or best_target:id() ~= LastTarget:id()) then
		last_switch_time = time_global() / 1000.0
	end

	LastTarget = best_target
end

-- Helper function for angle difference (handles wrap-around)
local function angle_diff(a, b)
	local d = b - a
	d = (d + math.pi) % (2 * math.pi) - math.pi
	return d
end

-- Updated to use mag_level instead of kind
function trace_target(obj, mag_level, dt)
	if not(obj) or not obj:alive() or not mag_level then
		LastTarget = nil
		return
	end
	
	local pos = obj:get_bone_id(bone) == 65535 and pos_y(obj) or utils_obj.safe_bone_pos(obj, bone)
	local is_visible = last_raycast_was_visible

	local tg = time_global()
	if raycast_timeout < tg then
		raycast_timeout = tg + raycast_delay
		local ray = pos and demonized_geometry_ray.geometry_ray({
			ray_range = 800,
			ignore_object = db.actor,
			flags = 3,
			--visualize = true, -- uncomment if you want to see where the rays go
		})
		local posFrom = device().cam_pos
		local posTo = vector():set(pos)
		local res = ray and ray:get(posFrom, posTo:sub(posFrom):normalize())
		if res.result.object and res.result.object:id() then
			--printf("raycast hit, expected: %s, %s", tostring(res.result.object:id()), obj:id())
		else
			--printf("raycast miss, expected: %s", obj:id())
		end
		last_raycast_was_visible = res.result and res.result.object and res.result.object:id() == obj:id() or false
		is_visible = last_raycast_was_visible
	end

	if pos and is_visible then
		local cam_pos = device().cam_pos
		local target_dir = vector():set(pos):sub(cam_pos):normalize()
		local current_dir = device().cam_dir

		local target_yaw = math.atan2(target_dir.x, target_dir.z)
		local target_pitch = -math.asin(target_dir.y)

		local current_yaw = math.atan2(current_dir.x, current_dir.z)
		local current_pitch = -math.asin(current_dir.y)

		local user_delta_yaw = angle_diff(last_set_yaw, current_yaw)
		local user_delta_pitch = angle_diff(last_set_pitch, current_pitch)

		local delta_yaw = angle_diff(current_yaw, target_yaw)
		local delta_pitch = angle_diff(current_pitch, target_pitch)

		local base_smooth = smooth_table[mag_level] or 0.01
		if base_smooth <= 0 then
			return
		end
		local frame_time = 1 / 60
		local k = -math.log(1 - base_smooth + 1e-10) / frame_time
		local effective_smooth = 1 - math.exp(-k * dt)

		local resistance_factor = 1.0
		local resist_speed_threshold = resist_threshold_table[mag_level] or 0.5
		
		-- Calculate current magnification to scale speeds (compensates for game's reduced aim sensitivity at zoom)
		local current_cam_fov = device().fov
		local mag = base_player_fov / current_cam_fov  -- mag >=1, higher at zoom
		
		local yaw_speed = math.abs(user_delta_yaw / dt) * mag
		local pitch_speed = math.abs(user_delta_pitch / dt) * mag
		
		if (user_delta_yaw * delta_yaw < 0 and yaw_speed > resist_speed_threshold) or 
		   (user_delta_pitch * delta_pitch < 0 and pitch_speed > resist_speed_threshold) then
			local tightness = retention_tightness_table[mag_level] or 1.0
			resistance_factor = 1.0 / math.max(tightness, 0.1)
		end

		effective_smooth = effective_smooth * resistance_factor

		local new_yaw = current_yaw + delta_yaw * effective_smooth
		local new_pitch = current_pitch + delta_pitch * effective_smooth

		db.actor:set_actor_direction(new_yaw, new_pitch)

		last_set_yaw = new_yaw
		last_set_pitch = new_pitch
	else
		LastTarget = nil
	end
end
-- ===================================================================

function aim_assist()
	-- This is the main logic change. We get the *mag level* instead of *weapon kind*.
	local mag_level = get_current_mag_level()
	if not mag_level then 
		-- This is a failsafe, but get_current_mag_level() should always return a value
		UnregisterScriptCallback("actor_on_update", aim_assist)
		return 
	end

	local current_time = time_global() / 1000.0
	if last_aim_time == 0 then 
		last_aim_time = current_time 
		return 
	end
	local dt = current_time - last_aim_time
	last_aim_time = current_time

	if LastTarget and is_valid_object(LastTarget) and dot_check(LastTarget, mag_level) then
		trace_target(LastTarget, mag_level, dt)
	else
		-- NEW: Check cooldown before searching for new target
		local cooldown = switch_cooldown_table[mag_level] or 0.0
		if current_time - last_switch_time >= cooldown then
			search_target(mag_level)
		end
		if LastTarget then
			trace_target(LastTarget, mag_level, dt)
		end
	end
end

-----------------------------------------------------------work states----------------------------------------------------------------------------------------------------

function actor_on_weapon_zoom_in()
	-- Check master toggle first
	if master_switch == 0 or not assist_toggled_on then return end
	
	-- No need to check weapon kind or work state!
	-- We just turn on the assist. aim_assist() will
	-- figure out the magnification level on its own.
	
	turn_on = true
	zoom_in = true
	RegisterScriptCallback("actor_on_update", aim_assist)
	
	if time_out_checkbox then
		CreateTimeEvent("time_out_ev", "time_out_act", time_out_input, function()
			UnregisterScriptCallback("actor_on_update", aim_assist)
			LastTarget = nil
			RemoveTimeEvent("time_out_ev", "time_out_act")
		end)
	end
end

function actor_on_weapon_zoom_out()
	zoom_in = false
	turn_on = true
	UnregisterScriptCallback("actor_on_update", aim_assist)
	LastTarget = nil
	last_set_yaw = 0
	last_set_pitch = 0
	last_switch_time = 0  -- Reset on zoom out
end

function handle_key_hold(key)
	-- Check master toggle first
	if master_switch == 0 or not assist_toggled_on then return end
	
	local bind = dik_to_bind(key)
	if (bind == key_bindings.kWPN_FIRE) then
		-- No need to check work_state. If the user is firing,
		-- we register the callback. aim_assist() will see
		-- zoom_in = false and correctly use the "hipfire" settings.
		RegisterScriptCallback("actor_on_update", aim_assist)
	end
end

function handle_key_release(key)
	local bind = dik_to_bind(key)
	if (bind == key_bindings.kWPN_FIRE) then
		-- If we are NOT ALSO zooming, turn off the script.
		-- This prevents releasing the fire key from stopping
		-- the aim assist if you are still holding right-click (zooming).
		if not zoom_in then
			UnregisterScriptCallback("actor_on_update", aim_assist)
			LastTarget = nil
			last_set_yaw = 0
			last_set_pitch = 0
			last_switch_time = 0  -- Reset on release
		end
	end
end

-- This function now ONLY handles the master toggle
function on_key_press(key)
	if (key == toggle_keybind) then
		assist_toggled_on = not assist_toggled_on
		
		-- If we just toggled it OFF, force the script to stop
		if not assist_toggled_on then
			UnregisterScriptCallback("actor_on_update", aim_assist)
			LastTarget = nil
			last_set_yaw = 0
			last_set_pitch = 0
			last_switch_time = 0
		end
	end
end

function delete_LastTarger(npc)
	if LastTarget and LastTarget:id() == npc:id() then
		LastTarget = nil
	end
end

function on_game_start()
	RegisterScriptCallback("actor_on_weapon_zoom_in", actor_on_weapon_zoom_in)
	RegisterScriptCallback("actor_on_weapon_zoom_out", actor_on_weapon_zoom_out)
	RegisterScriptCallback("actor_on_weapon_lower", actor_on_weapon_zoom_out)
	
	RegisterScriptCallback("on_key_hold", handle_key_hold)
	RegisterScriptCallback("on_key_release", handle_key_release)
	
	RegisterScriptCallback("on_key_press",on_key_press)
	
	RegisterScriptCallback("npc_on_net_destroy", delete_LastTarger)
	RegisterScriptCallback("monster_on_net_destroy", delete_LastTarger)
	RegisterScriptCallback("npc_on_death_callback", delete_LastTarger)
	RegisterScriptCallback("monster_on_death_callback", delete_LastTarger)
	RegisterScriptCallback("on_option_change", on_option_change)
	on_option_change()
end