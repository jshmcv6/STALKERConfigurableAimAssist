local zoom_in = false
local LastTarget = nil
local turn_on = true
local assist_toggled_on = true -- This is our master toggle

-- We will store settings in these tables
local work_state_table = {}
local radius_table = {}
local smooth_table = {}
local retention_table = {}
local retention_tightness_table = {}
-- (Recoil Comp table removed)

local weapon_kinds = {
	["w_pistol"] = "pistol",
	["w_smg"] = "smg",
	["w_rifle"] = "rifle",
	["w_shotgun"] = "shotgun",
	["w_sniper"] = "sniper",
	["w_explosive"] = "explosive"
}

local last_aim_time = 0
local last_set_yaw = 0
local last_set_pitch = 0

local raycast_timeout = 0
local raycast_delay = 60 -- 10 real ms between raycasts because in-game time is 6 : 1 real-time
local last_raycast_was_visible = true
-------------------------------------------------MCM stuff--------------------------------------------------------------------------------

local get_config = aim_mcm.get_config

function translate_bone(number)
	local bone_guide = {
		[1] = "bip01_head",
		[2] = "bip01_neck",
		[3] = "bip01_spine",
	}
	return bone_guide[number]
end

function on_option_change()
	-- Load Global Settings
	master_switch = get_config("master_switch")
	bone = translate_bone( get_config("main_bone") )
	toggle_keybind = get_config("toggle_keybind")
	time_out_checkbox = get_config("time_out_checkbox")
	time_out_input = tonumber(get_config("time_out_input")) or 0.5
	limit_mode = get_config("limit_mode")
	limit_value = tonumber(get_config("limit_value")) or 10
	frendly_fire = get_config("frendly_fire")
	closer_wider = get_config("closer_wider")
	closer_wider_value = tonumber(get_config("closer_wider_value")) or 0.7
	closer_wider_distance = tonumber(get_config("closer_wider_distance")) or 0
	
	-- Load Per-Weapon Settings into our tables
	for game_kind, mcm_kind in pairs(weapon_kinds) do
		work_state_table[game_kind] = get_config(mcm_kind .. "_work_state")
		radius_table[game_kind] = tonumber(get_config(mcm_kind .. "_radius")) or 0.995
		smooth_table[game_kind] = tonumber(get_config(mcm_kind .. "_smooth_factor")) or 0.01
		retention_table[game_kind] = tonumber(get_config(mcm_kind .. "_retention_radius")) or 0.995
		retention_tightness_table[game_kind] = tonumber(get_config(mcm_kind .. "_retention_tightness")) or 1.0
		-- (Recoil Comp load removed)
	end
	
	-- Handle the Master Switch
	if master_switch == 0 then
		UnregisterScriptCallback("actor_on_update", aim_assist)
		LastTarget = nil
	end
end

local function limit_equation(obj)
	local dist = distance_between_safe(db.actor, obj)
	if not dist or type(dist) ~= "number" or dist ~= dist then
		return false
	end
	return limit_mode == 0 or
	(limit_mode == -1) and (dist <= limit_value) or
	(limit_mode == 1) and (dist >= limit_value)
end

function get_current_weapon_kind()
	local wpn = db.actor:active_item()
	if wpn and IsWeapon(wpn) then
		local kind = ini_sys:r_string_ex(wpn:section(),"kind")
		if weapon_kinds[kind] then
			return kind
		end
	end
	return nil
end

---------------------------------------------main------------------------------------------------------------------------------------

function dot_eye(position)
	if not position then return nil end
	local toPoint = vector():set(position):sub(device().cam_pos):normalize()
	local toEye = device().cam_dir
	local dot = toPoint:dotproduct(toEye)
	return dot
end

local function pos_y(obj)
	if not(obj) then return nil end
	local pos = vector():set(obj:position())
	pos.y = pos.y + 1
	return pos
end

function is_valid_object(obj)
	if not(obj) then return end
	if not limit_equation(obj) then return end
	
	if ( (frendly_fire and IsStalker(obj)) or
	(IsStalker(obj) and (obj:relation(db.actor) >= game_object.enemy)) or
	IsMonster(obj) ) and
	obj:alive() and db.actor:see(obj) or
	IsHelicopter(obj) and obj:alive()
	then
		return true
	else
		return
	end
end

function dot_check(obj, kind)
	if not(obj) or not kind then return end
	if not obj:alive() then return nil end  -- Added to prevent crashes on dead objects
	
	local pos = obj:get_bone_id(bone) == 65535 and pos_y(obj) or utils_obj.safe_bone_pos(obj, bone)
	if not pos then return nil end  -- Existing check
	
	local dot = dot_eye(pos)
	if not dot then return nil end  -- Added to handle any failure in dot_eye
	
	local active_radius = radius_table[kind] or 0.995 
	local retention_radius = retention_table[kind] or 0.995
	local retention_tightness = retention_tightness_table[kind] or 1.0
	
	local trigger_zone = active_radius
	if LastTarget and obj:id() == LastTarget:id() then
		trigger_zone = 1 - math.pow(1 - retention_radius, retention_tightness)
		trigger_zone = math.min(trigger_zone, 1.0)  -- Cap at 1 to prevent instant break
	end
	
	local dist = distance_between_safe(db.actor, obj)
	if closer_wider and dist and type(dist) == "number" and dist == dist and type(closer_wider_distance) == "number" and closer_wider_distance == closer_wider_distance and type(closer_wider_value) == "number" and closer_wider_value == closer_wider_value and dist <= closer_wider_distance then
		trigger_zone = math.min(trigger_zone, closer_wider_value)
	end

	if type(dot) ~= "number" or type(trigger_zone) ~= "number" or dot ~= dot or trigger_zone ~= trigger_zone then
		return nil
	end

	if dot >= trigger_zone then
		return dot
	else
		return nil
	end
end

function search_target(kind)
	if not kind then return end
	local t = db.storage
	local best_dot = -1
	local best_target = nil

	for id, st in pairs(t) do
		if st.object and is_valid_object(st.object) then
			local dot = dot_check(st.object, kind) 
			if dot and type(dot) == "number" and dot == dot and dot > best_dot then
				best_dot = dot
				best_target = st.object
			end
		end
	end

	LastTarget = best_target
end

-- Helper function for angle difference (handles wrap-around)
local function angle_diff(a, b)
	local d = b - a
	d = (d + math.pi) % (2 * math.pi) - math.pi
	return d
end

-- ===================================================================
-- THIS IS THE CORRECTED FUNCTION - Now with smooth interpolation
-- ===================================================================
function trace_target(obj, kind, dt)
	if not(obj) or not obj:alive() or not kind then
		LastTarget = nil
		return
	end
	
	-- Get target position (with fallback)
	local pos = obj:get_bone_id(bone) == 65535 and pos_y(obj) or utils_obj.safe_bone_pos(obj, bone)
	local is_visible = last_raycast_was_visible

	local tg = time_global()
	if raycast_timeout < tg then
		raycast_timeout = tg + raycast_delay
		local ray = pos and demonized_geometry_ray.geometry_ray({
			ray_range = 800,
			ignore_object = db.actor,
			flags = 3,
			--visualize = true, -- uncomment if you want to see where the rays go
		})
		local posFrom = device().cam_pos
		local posTo = vector():set(pos)
		local res = ray and ray:get(posFrom, posTo:sub(posFrom):normalize())
		if res.result.object and res.result.object:id() then
			--printf("raycast hit, expected: %s, %s", tostring(res.result.object:id()), obj:id())
		else
			--printf("raycast miss, expected: %s", obj:id())
		end
		last_raycast_was_visible = res.result and res.result.object and res.result.object:id() == obj:id() or false
		is_visible = last_raycast_was_visible
	end

	if pos and is_visible then
		local cam_pos = device().cam_pos
		local target_dir = vector():set(pos):sub(cam_pos):normalize()
		local current_dir = device().cam_dir

		-- Calculate target yaw and pitch
		local target_yaw = math.atan2(target_dir.x, target_dir.z)
		local target_pitch = -math.asin(target_dir.y)  -- Adjust sign if pitch is inverted in-game

		-- Calculate current yaw and pitch
		local current_yaw = math.atan2(current_dir.x, current_dir.z)
		local current_pitch = -math.asin(current_dir.y)

		-- Detect user input delta (difference from last set direction)
		local user_delta_yaw = angle_diff(last_set_yaw, current_yaw)
		local user_delta_pitch = angle_diff(last_set_pitch, current_pitch)

		-- Calculate deltas to target
		local delta_yaw = angle_diff(current_yaw, target_yaw)
		local delta_pitch = angle_diff(current_pitch, target_pitch)

		-- Calculate effective smooth factor (frame-rate independent)
		local base_smooth = smooth_table[kind] or 0.01
		if base_smooth <= 0 then
			return  -- No pull if 0 or negative
		end
		local frame_time = 1 / 60  -- Assume 60 FPS base
		local k = -math.log(1 - base_smooth + 1e-10) / frame_time  -- Decay rate
		local effective_smooth = 1 - math.exp(-k * dt)

		-- Detect if user is resisting (moving away from target)
		local resistance_factor = 1.0
		local resist_speed_threshold = 0.5  -- rad/s, adjust if needed (e.g., increase to 1.0 if sway still triggers)
		local yaw_speed = math.abs(user_delta_yaw / dt)
		local pitch_speed = math.abs(user_delta_pitch / dt)
		if (user_delta_yaw * delta_yaw < 0 and yaw_speed > resist_speed_threshold) or 
		   (user_delta_pitch * delta_pitch < 0 and pitch_speed > resist_speed_threshold) then
			local tightness = retention_tightness_table[kind] or 1.0
			resistance_factor = 1.0 / math.max(tightness, 0.1)  -- Higher tightness = lower factor (weaker pull when resisting)
		end

		-- Apply resistance to smooth factor
		effective_smooth = effective_smooth * resistance_factor

		-- Apply effective smooth factor (pull strength)
		local new_yaw = current_yaw + delta_yaw * effective_smooth
		local new_pitch = current_pitch + delta_pitch * effective_smooth

		-- Set the new direction
		db.actor:set_actor_direction(new_yaw, new_pitch)

		-- Update last set for next frame
		last_set_yaw = new_yaw
		last_set_pitch = new_pitch
	else
		-- Failsafe
		LastTarget = nil
	end
end
-- ===================================================================

function aim_assist()
	local kind = get_current_weapon_kind()
	if not kind then 
		UnregisterScriptCallback("actor_on_update", aim_assist)
		return 
	end

	-- Calculate dt for frame-rate independence
	local current_time = time_global() / 1000.0  -- time_global in ms
	if last_aim_time == 0 then 
		last_aim_time = current_time 
		return 
	end
	local dt = current_time - last_aim_time
	last_aim_time = current_time

	if LastTarget and is_valid_object(LastTarget) and dot_check(LastTarget, kind) then
		trace_target(LastTarget, kind, dt)
	else
		search_target(kind)
		if LastTarget then
			trace_target(LastTarget, kind, dt)
		end
	end
end

-----------------------------------------------------------work states----------------------------------------------------------------------------------------------------

function actor_on_weapon_zoom_in()
	-- Check master toggle first
	if master_switch == 0 or not assist_toggled_on then return end
	
	local kind = get_current_weapon_kind()
	if not kind then return end

	turn_on = true
	zoom_in = true
	-- Check if THIS weapon is set to Zoom Mode (1)
	if work_state_table[kind] == 1 then
		RegisterScriptCallback("actor_on_update", aim_assist)
		if time_out_checkbox then
			CreateTimeEvent("time_out_ev", "time_out_act", time_out_input, function()
				UnregisterScriptCallback("actor_on_update", aim_assist)
				LastTarget = nil
				RemoveTimeEvent("time_out_ev", "time_out_act")
			end)
		end
	end
end

function actor_on_weapon_zoom_out()
	zoom_in = false
	turn_on = true
	UnregisterScriptCallback("actor_on_update", aim_assist)
	LastTarget = nil
	last_set_yaw = 0
	last_set_pitch = 0
end

function handle_key_hold(key)
	-- Check master toggle first
	if master_switch == 0 or not assist_toggled_on then return end
	
	local kind = get_current_weapon_kind()
	if not kind then return end
	
	local current_work_state = work_state_table[kind]

	-- Logic for "Fire Mode" (3)
	if (current_work_state == 3) then
		local bind = dik_to_bind(key)
		if (bind == key_bindings.kWPN_FIRE) then
			RegisterScriptCallback("actor_on_update", aim_assist)
		end
	end
end

function handle_key_release(key)
	local kind = get_current_weapon_kind()
	local current_work_state = kind and work_state_table[kind] or nil

	-- Logic for "Fire Mode" (3)
	if (current_work_state == 3) then
		local bind = dik_to_bind(key)
		if (bind == key_bindings.kWPN_FIRE) then
			UnregisterScriptCallback("actor_on_update", aim_assist)
			LastTarget = nil
			last_set_yaw = 0
			last_set_pitch = 0
		end
	end
end

-- This function now ONLY handles the master toggle
function on_key_press(key)
	if (key == toggle_keybind) then
		assist_toggled_on = not assist_toggled_on
		
		-- If we just toggled it OFF, force the script to stop
		if not assist_toggled_on then
			UnregisterScriptCallback("actor_on_update", aim_assist)
			LastTarget = nil
			last_set_yaw = 0
			last_set_pitch = 0
		end
	end
end

function delete_LastTarger(npc)
	if LastTarget and LastTarget:id() == npc:id() then
		LastTarget = nil
	end
end

function on_game_start()
	RegisterScriptCallback("actor_on_weapon_zoom_in", actor_on_weapon_zoom_in)
	RegisterScriptCallback("actor_on_weapon_zoom_out", actor_on_weapon_zoom_out)
	RegisterScriptCallback("actor_on_weapon_lower", actor_on_weapon_zoom_out)
	
	RegisterScriptCallback("on_key_hold", handle_key_hold)
	RegisterScriptCallback("on_key_release", handle_key_release)
	
	RegisterScriptCallback("on_key_press",on_key_press)
	
	RegisterScriptCallback("npc_on_net_destroy", delete_LastTarger)
	RegisterScriptCallback("monster_on_net_destroy", delete_LastTarger)
	RegisterScriptCallback("npc_on_death_callback", delete_LastTarger)
	RegisterScriptCallback("monster_on_death_callback", delete_LastTarger)
	RegisterScriptCallback("on_option_change", on_option_change)
	on_option_change()
end